# Implementation Plan: Migration from Environment Variables to graph.yaml for LLM Configuration

## Архитектура решения

### 1. Конфигурационная система
- **Расширение graph.yaml**: Добавить секцию `models` с конфигурацией для каждого узла
- **Фабрика моделей**: Создать `ModelFactory` класс для создания LLM моделей на основе конфигурации
- **Конфигурационный валидатор**: Добавить валидацию YAML схемы с помощью Pydantic
- **Менеджер конфигурации**: Создать `GraphConfigManager` для загрузки и управления конфигурацией

### 2. Интеграция с узлами
- **Миграция узлов**: Обновить все существующие узлы для использования нового подхода
- **Единообразие**: Привести все узлы к единому способу получения модельной конфигурации

### 3. Структура конфигурации
```yaml
# Новая структура graph.yaml
models:
  default:
    provider: "openai"
    model_name: "gpt-4o-mini"
    temperature: 0.1
    max_tokens: 4000
  
  nodes:
    input_processing:
      model_name: "gpt-4o-mini"
      temperature: 0.0
      max_tokens: 1500
    
    generating_content:
      model_name: "gpt-4o"
      temperature: 0.2
      max_tokens: 8000
    
    recognition_handwritten:
      model_name: "gpt-4o"
      temperature: 0.1
      max_tokens: 6000
    
    synthesis_material:
      model_name: "gpt-4o"
      temperature: 0.1
      max_tokens: 8000
    
    generating_questions:
      model_name: "gpt-4o-mini"
      temperature: 0.3
      max_tokens: 3000
    
    answer_question:
      model_name: "gpt-4o"
      temperature: 0.2
      max_tokens: 6000

# Существующие секции остаются без изменений
graph_config:
  # ...существующий контент
```

## API и интерфейсы

### 1. GraphConfigManager
**Расположение**: `learnflow/config_manager.py`

**Методы**:
- `load_config(config_path: str) -> GraphConfig`: Загружает и валидирует конфигурацию из YAML
- `get_model_config(node_name: str) -> ModelConfig`: Возвращает конфигурацию модели для узла
- `get_default_model_config() -> ModelConfig`: Возвращает дефолтную конфигурацию модели

**Параметры**: 
- `config_path`: Путь к файлу graph.yaml
- `node_name`: Имя узла workflow (например, "generating_content")

**Возвращаемые значения**:
- `GraphConfig`: Pydantic модель с полной конфигурацией
- `ModelConfig`: Конфигурация конкретной модели с параметрами генерации

### 2. ModelFactory
**Расположение**: `learnflow/model_factory.py`

**Методы**:
- `create_model(config: ModelConfig, api_key: str) -> ChatOpenAI`
- `create_model_for_node(node_name: str, api_key: str) -> ChatOpenAI`: Создает модель для конкретного узла

**Параметры**:
- `config`: Конфигурация модели (ModelConfig)
- `api_key`: OpenAI API ключ
- `node_name`: Имя узла для автоматического получения конфигурации

**Возвращаемые значения**:
- `ChatOpenAI`: Сконфигурированная модель LangChain

### 3. Pydantic модели конфигурации
**Расположение**: `learnflow/config_models.py`

**Классы**:
- `ModelConfig`: Конфигурация одной LLM модели
- `LLMModelsConfig`: Конфигурация всех моделей (default + nodes)
- `GraphConfig`: Полная конфигурация графа (включая существующие секции)

**Поля ModelConfig**:
- `provider: str = "openai"`: Провайдер LLM
- `model_name: str`: Имя модели
- `temperature: float`: Temperature для генерации
- `max_tokens: int`: Максимальное количество токенов
- `top_p: Optional[float]`: Top-p параметр
- `frequency_penalty: Optional[float]`: Penalty за частоту
- `presence_penalty: Optional[float]`: Penalty за присутствие

### 4. Модификация узлов
**Методы для добавления в каждый узел**:
- `get_model_config() -> ModelConfig`: Получает конфигурацию модели для узла
- `create_model() -> ChatOpenAI`: Создает модель на основе конфигурации
- `get_node_name() -> str`: Возвращает имя узла для поиска конфигурации

## Взаимодействие компонентов

### 1. Инициализация системы
1. `GraphConfigManager` загружает `graph.yaml` при старте приложения
2. Конфигурация валидируется через Pydantic модели
3. `ModelFactory` регистрируется как singleton с доступом к конфигурации

### 2. Создание узлов workflow
1. Каждый узел в `__init__()` вызывает `self.create_model()`
2. `create_model()` использует `ModelFactory.create_model_for_node()`
3. `ModelFactory` получает конфигурацию через `GraphConfigManager.get_model_config()`
4. При отсутствии конфигурации для узла используется `default` конфигурация

### 3. Fallback стратегия
1. Если `graph.yaml` не найден или поврежден - приложение завершается с ошибкой
2. Если конфигурация узла отсутствует - используется `default` из `models`
3. Если `default` отсутствует - используются значения по умолчанию из кода

### 4. Интеграция с настройками
- `AppSettings` сохраняет только `openai_api_key` для доступа к OpenAI API
- Все параметры моделей (`model_name`, `temperature`) полностью переносятся в `graph.yaml`
- Упрощение настроек для MVP версии

## Edge Cases и особенности

### 1. Простая миграция для MVP
- **Подход**: Полный переход на конфигурацию через graph.yaml без обратной совместимости
- **Решение**: Прямая замена переменных окружения на YAML конфигурацию
- **Простота**: Минимальная сложность реализации для MVP стадии

### 2. Валидация конфигурации
- **Проблема**: Некорректный YAML может сломать систему
- **Решение**: Строгая валидация через Pydantic с информативными ошибками
- **Обработка ошибок**: При ошибке валидации - завершение работы с понятным сообщением об ошибке

### 3. Динамическая перезагрузка
- **Проблема**: Изменения конфигурации требуют перезапуска сервиса
- **Решение**: Для первой версии - оставить статическую загрузку при старте
- **Будущее**: Добавить file watcher для hot-reload конфигурации

### 4. Производительность
- **Проблема**: Частое чтение YAML файла может замедлить систему
- **Решение**: Кэширование конфигурации в памяти после первой загрузки
- **Инвалидация**: Перезагрузка только при изменении файла или restart

### 5. Обработка отсутствующих узлов
- **Проблема**: Новые узлы могут не иметь конфигурации в graph.yaml
- **Решение**: Автоматическое использование `default` конфигурации
- **Логирование**: Предупреждение в логах о использовании default конфигурации

### 6. Конфликты параметров
- **Проблема**: Один узел может иметь параметры как в graph.yaml, так и в коде
- **Решение**: graph.yaml имеет высший приоритет, код служит fallback
- **Документация**: Четкие правила приоритетов в комментариях

### 7. Multi-environment поддержка
- **Проблема**: Разные окружения (dev/prod) могут требовать разных моделей
- **Решение**: Поддержка переменных окружения в graph.yaml через ${ENV_VAR} синтаксис
- **Альтернатива**: Разные graph.yaml файлы для разных окружений

## Этапы реализации

### Этап 1: Создание базовой инфраструктуры
1. Создать Pydantic модели в `learnflow/config_models.py`
2. Реализовать `GraphConfigManager` в `learnflow/config_manager.py`
3. Создать `ModelFactory` в `learnflow/model_factory.py`
4. Добавить базовый `configs/graph.yaml` с примером конфигурации

### Этап 2: Подготовка базовой логики для узлов
1. Создать общие helper функции для работы с конфигурацией моделей
2. Определить интерфейс для методов `get_node_name()`, `get_model_config()` и `create_model()`
3. Создать базовые реализации этих методов
4. Подготовить примеры интеграции для узлов

### Этап 3: Миграция узлов
1. Обновить все существующие узлы для реализации `get_node_name()`
2. Убрать прямые обращения к `AppSettings` для получения модели
3. Протестировать каждый узел с новой системой конфигурации

### Этап 4: Интеграция и тестирование
1. Упростить `AppSettings`, убрав ненужные поля моделей
2. Добавить интеграционные тесты для различных сценариев
3. Создать документацию по новой системе конфигурации
4. Добавить валидацию конфигурации при старте приложения

### Этап 5: Финализация
1. Добавить логирование и мониторинг новой системы
2. Создать примеры конфигураций для разных окружений
3. Обновить документацию проекта
4. Подготовить план миграции для production